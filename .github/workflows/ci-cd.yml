name: CI/CD Pipeline

on:
  push:
    branches:
      - production # Dispara el workflow cuando se haga push a la rama 'production'
  pull_request:
    branches:
      - production
  workflow_dispatch: # Permite ejecutar el workflow manualmente desde GitHub UI

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18' # Asegúrate de que esta versión sea compatible con tu proyecto React

      - name: Cache Node.js modules for 'back'
        uses: actions/cache@v4
        with:
          path: back/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('back/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
        
      - name: Install dependencies in 'back'
        working-directory: ./back
        run: npm ci

      - name: Run tests in 'back'
        working-directory: ./back
        run: npm test

      - name: Cache Node.js modules for 'gallery-images'
        uses: actions/cache@v4
        with:
          path: gallery-images/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('gallery-images/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
        
      - name: Install dependencies in 'gallery-images'
        working-directory: ./gallery-images
        run: npm ci

      - name: Run tests in 'gallery-images'
        working-directory: ./gallery-images
        run: npm test

      - name: CI Completed Successfully
        run: echo "🎉 CI Pipeline finalizado con éxito para back y gallery-images!"

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test # Este job SOLO se ejecutará si el job 'build-and-test' pasa exitosamente.
    environment: production 
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up SSH Key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add Server to Known Hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Build React Frontend
        uses: actions/setup-node@v4 # Necesitamos Node.js para construir React
        with:
          node-version: '18' # Asegúrate de que esta versión sea compatible con tu proyecto React
      - name: Cache Node.js modules for 'front'
        uses: actions/cache@v4
        with:
          path: front/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('front/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      - name: Install dependencies for 'front'
        working-directory: ./front
        run: npm ci
      - name: Run build for 'front'
        working-directory: ./front
        run: npm run build # Este comando creará la carpeta 'dist' (o 'build') con los estáticos

      - name: Deploy Application
        run: |
          REMOTE_DIR="/home/${{ secrets.SERVER_USER }}/app-gallery" # Directorio donde se copiará el proyecto
          FRONT_BUILD_DIR="./front/dist" # Asumiendo que Vite crea la salida en 'dist'
          
          echo "Conectando al servidor: ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}"
          
          # Crear el directorio remoto si no existe
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p $REMOTE_DIR"
          
          # Sincronizar el contenido del proyecto (excluyendo .git, node_modules, .github, y la carpeta 'front')
          # ¡Importante!: La carpeta 'front' solo se copiará después de la construcción
          echo "Copiando archivos del backend y microservicios al servidor..."
          rsync -avz --delete --exclude '.git/' --exclude 'node_modules/' --exclude '.github/' --exclude 'front/' \
            ./ ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$REMOTE_DIR/

          echo "Copiando la carpeta de build de frontend al servidor..."
          # Copiar SÓLO la carpeta de build del frontend (ej. 'dist')
          rsync -avz "$FRONT_BUILD_DIR"/ ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$REMOTE_DIR/front_build/ # Copiar a un directorio específico en el servidor

          echo "Configurando y levantando servicios Docker en el servidor..."
          # Ejecutar los comandos en el servidor remoto
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            cd "$REMOTE_DIR"
            
            # Dar permisos de ejecución al script start-services.sh
            chmod +x start-services.sh
            
            # Ejecutar start-services.sh y responder 'y' para --build
            echo "y" | ./start-services.sh
            
            # --- Configuración para servir el frontend ---
            # Aquí la lógica cambia drásticamente. Necesitas un servidor web
            # (como Nginx) para servir los archivos estáticos de React.
            # No se ejecuta 'npm run start' para el frontend.
            # En su lugar, debes asegurarte de que tu configuración de Nginx (o similar)
            # en el servidor apunte al directorio donde copiaste el build de React.

            # Ejemplo (si Nginx ya está configurado para servir '/var/www/html' o similar):
            # Asumiendo que tu Nginx está configurado para servir /var/www/html/app-gallery-front
            # Y que tienes un proxy_pass para el backend
            echo "Actualizando archivos estáticos del frontend..."
            # Elimina el contenido antiguo y mueve los nuevos archivos de build
            # Asegúrate que el usuario deploy tenga permisos para esto
            rm -rf /var/www/html/app-gallery-front/* 2>/dev/null || true
            mkdir -p /var/www/html/app-gallery-front
            mv "$REMOTE_DIR"/front_build/* /var/www/html/app-gallery-front/
            
            # Recargar Nginx si es necesario para aplicar cualquier cambio de configuración
            # (Esto asume que ya tienes Nginx instalado y configurado para tu frontend)
            # Si tu Nginx ya está en Docker Compose, el despliegue de Nginx sería parte de start-services.sh
            # y solo necesitarías asegurarte de que los archivos se copien al volumen correcto de Nginx.
            # sudo systemctl reload nginx # Descomentar si Nginx está instalado directamente en el servidor host

            echo "Proceso de despliegue en el servidor completado."
            EOF
      - name: Deployment Completed
        run: echo "🚀 Despliegue completado en el servidor remoto ${{ secrets.SERVER_HOST }}!"